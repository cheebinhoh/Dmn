/**
 * Copyright © 2025 Chee Bin HOH. All rights reserved.
 *
 * @file dmn-dmesgnet.cpp
 * @brief Dmn_DMesgNet — network-aware DMesg extension.
 */

#include "dmn-dmesgnet.hpp"

#include <sys/time.h>

#include <cassert>
#include <chrono>
#include <memory>
#include <string>
#include <string_view>
#include <utility>

#include "dmn-async.hpp"
#include "dmn-dmesg-pb-util.hpp"
#include "dmn-dmesg.hpp"
#include "dmn-io.hpp"
#include "dmn-proc.hpp"
#include "dmn-timer.hpp"

#include "proto/dmn-dmesg-body.pb.h"
#include "proto/dmn-dmesg-type.pb.h"

namespace dmn {

Dmn_DMesgNet::Dmn_DMesgNet(std::string_view name,
                           std::shared_ptr<Dmn_Io<std::string>> input_handler,
                           std::shared_ptr<Dmn_Io<std::string>> output_handler)
    : Dmn_DMesg{name}, m_name{name}, m_input_handler{std::move(input_handler)},
      m_output_handler{std::move(output_handler)} {

  // Initialize the DMesgNet state
  struct timeval tval{};
  gettimeofday(&tval, nullptr);

  DMESG_PB_SET_MSG_TOPIC(this->m_sys, kDMesgSysIdentifier);
  DMESG_PB_SET_MSG_TYPE(this->m_sys, dmn::DMesgTypePb::sys);

  DMESG_PB_SYS_SET_TIMESTAMP_FROM_TV(this->m_sys, tval);

  auto *self = this->m_sys.mutable_body()->mutable_sys()->mutable_self();
  DMESG_PB_SYS_NODE_SET_INITIALIZEDTIMESTAMP_FROM_TV(self, tval);
  DMESG_PB_SYS_NODE_SET_UPDATEDTIMESTAMP_FROM_TV(self, tval);
  DMESG_PB_SYS_NODE_SET_IDENTIFIER(self, this->m_name);
  DMESG_PB_SYS_NODE_SET_STATE(self, dmn::DMesgStatePb::MasterPending);
  DMESG_PB_SYS_NODE_SET_MASTERIDENTIFIER(self, "");

  this->createSubscriptHandler();
  this->createInputHandlerProc();
  this->createTimerProc();

  if (m_sys_handler) {
    m_sys_handler->write(this->m_sys);
  }
}

Dmn_DMesgNet::~Dmn_DMesgNet() noexcept try {
  // it is important that we free up m_input_handler as if it is a
  // kafka handler, it will be continuing to be feed of incoming
  // message and including one that is generated by this dmesgnet,
  // and that will prolong it closing.

  m_shutdown = true;

  m_write_handler.reset();
  m_input_handler.reset();
  m_input_proc.reset();
  m_timer_proc.reset();

  if (m_output_handler) {
    // it is about to destroy the Dmn_DMesgNet and free everything
    // it will send last heartbeat and reliquinsh itself as master (if
    // itself is master).
    //
    // we avoid use of m_sys_handler as we are to destroy it, so we
    // do not want to hold the object life up and have to wait for
    // asynchrononous action to send last heartbeat messge.
    struct timeval tval{};
    gettimeofday(&tval, nullptr);

    DMESG_PB_SET_MSG_SOURCEIDENTIFIER(this->m_sys, this->m_name);
    DMESG_PB_SET_MSG_SOURCEWRITEHANDLERIDENTIFIER(this->m_sys, this->m_name);

    auto *self = this->m_sys.mutable_body()->mutable_sys()->mutable_self();

    DMESG_PB_SYS_NODE_SET_STATE(self, dmn::DMesgStatePb::Destroyed);
    DMESG_PB_SYS_NODE_SET_MASTERIDENTIFIER(self, "");
    DMESG_PB_SYS_NODE_SET_UPDATEDTIMESTAMP_FROM_TV(self, tval);

    std::string serialized_string{};
    this->m_sys.SerializeToString(&serialized_string);

    m_output_handler->write(serialized_string);
  }

  if (m_sys_handler) {
    Dmn_DMesg::closeHandler(m_sys_handler);
  }

  if (m_subscript_handler) {
    Dmn_DMesg::closeHandler(m_subscript_handler);
  }
  std::cout << "net destroy 10\n";
} catch (...) {
  // explicit return to resolve exception as destructor must be noexcept
  return;
}

void Dmn_DMesgNet::createInputHandlerProc() {
  if (m_input_handler) {
    m_write_handler = Dmn_DMesg::openHandler(
        m_name, [this](const dmn::DMesgPb &) -> bool { return false; },
        [](dmn::DMesgPb dmesgPbWrite) mutable -> void {});

    m_input_proc =
        std::make_unique<Dmn_Proc>(m_name + "_inputProc", [this]() -> void {
          while (this->m_input_handler && !m_shutdown) {
            dmn::DMesgPb dmesgpb_read{};

            auto data = this->m_input_handler->read();
            if (m_shutdown) {
              break;
            }

            Dmn_Proc::yield();

            if (data) {
              dmesgpb_read.ParseFromString(*data);
              if (dmesgpb_read.sourcewritehandleridentifier() == this->m_name) {
                continue;
              }

              // this is important to prevent that the
              // m_subscript_handler of this DMesgNet from
              // reading this message again and send out.
              //
              // the Dmn_DMesgHandler->write will add the name
              // of the Dmn_DMesgHandler from read it again,
              // but it is good to be explicit.

              if (dmesgpb_read.type() == dmn::DMesgTypePb::sys) {
                DMN_ASYNC_CALL_WITH_CAPTURE(
                    { this->reconciliateDMesgPbSys(dmesgpb_read); }, this,
                    dmesgpb_read);
              } else if (dmesgpb_read.conflict()) {
                auto lastMesgPb =
                    this->getTopicLastMessage(dmesgpb_read.topic());
                assert(lastMesgPb);

                DMN_ASYNC_CALL_WITH_CAPTURE(
                    {
                      if (m_is_master) {
                        std::string serialized_string{};

                        DMESG_PB_SET_MSG_PLAYBACK(dmesgpbForce, true);
                        DMESG_PB_SET_MSG_FORCE(dmesgpbForce, true);

                        dmesgpbForce.SerializeToString(&serialized_string);
                        m_output_handler->write(serialized_string);
                      }
                    },
                    this, dmesgpbForce = *lastMesgPb);
              } else if (dmesgpb_read.force() && dmesgpb_read.playback()) {
                bool ok = m_write_handler->writeAndCheckConflict(dmesgpb_read);
                if (ok) {
                  DMN_ASYNC_CALL_WITH_CAPTURE(
                      {
                        m_topic_last_dmesgpb[dmesgpb_read.topic()] =
                            dmesgpb_read;
                      },
                      this, dmesgpb_read);
                } else {
                  assert("force and playback write fail" == nullptr);
                }
              } else {
                DMESG_PB_SET_MSG_SOURCEWRITEHANDLERIDENTIFIER(dmesgpb_read,
                                                              this->m_name);

                auto lastMesgPb =
                    this->getTopicLastMessage(dmesgpb_read.topic());
                if (lastMesgPb && lastMesgPb->runningcounter() >=
                                      dmesgpb_read.runningcounter()) {
                  DMESG_PB_SET_MSG_CONFLICT(dmesgpb_read, true);
                }

                bool ok = m_write_handler->writeAndCheckConflict(dmesgpb_read);

                if (ok) {
                  DMN_ASYNC_CALL_WITH_CAPTURE(
                      {
                        m_topic_last_dmesgpb[dmesgpb_read.topic()] =
                            dmesgpb_read;
                      },
                      this, dmesgpb_read);
                } else {
                  DMN_ASYNC_CALL_WITH_CAPTURE(
                      {
                        DMESG_PB_SET_MSG_CONFLICT(dmesgpb_read, true);

                        std::string serialized_string{};
                        dmesgpb_read.SerializeToString(&serialized_string);
                        m_output_handler->write(serialized_string);

                        DMESG_PB_SET_MSG_PLAYBACK(dmesgpbForce, true);
                        DMESG_PB_SET_MSG_FORCE(dmesgpbForce, true);

                        dmesgpbForce.SerializeToString(&serialized_string);
                        m_output_handler->write(serialized_string);
                      },
                      this, dmesgpb_read, dmesgpbForce = *lastMesgPb);
                }
              } /* else (dmesgpb_read.type() == dmn::DMesgTypePb::sys) */
            }
          }
        });

    m_input_proc->exec();

    m_sys_handler = Dmn_DMesg::openHandler(
        m_name + "_sys",
        []([[maybe_unused]] const dmn::DMesgPb &dmesgpb) -> bool {
          return false;
        },
        nullptr, Dmn_DMesg::kHandlerConfig_Default);
  }
}

void Dmn_DMesgNet::createSubscriptHandler() {
  auto handlerConfig = Dmn_DMesg::kHandlerConfig_Default;
  handlerConfig[std::string{Dmn_DMesg::kHandlerConfig_IncludeSys}] = "yes";
  handlerConfig[std::string{Dmn_DMesg::kHandlerConfig_NoTopicFilter}] = "yes";

  // subscriptHandler to read and write with local DMesg
  m_subscript_handler = Dmn_DMesg::openHandler(
      m_name + "_sub",
      [this](const dmn::DMesgPb &dmesgPb) -> bool {
        return dmesgPb.sourcewritehandleridentifier() != this->m_name;
      },
      [this](dmn::DMesgPb dmesgPbWrite) mutable -> void {
        if (m_output_handler) {
          DMN_ASYNC_CALL_WITH_CAPTURE(
              {
                std::string serialized_string{};

                // set the source, so that we can skip it if the
                // data is read back over the input Dmn_Io.
                //
                // FIXME: shall we generate UUID internally to guarantee
                // uniqueness across networked nodes or global Internet?
                //
                // This is point we check if outgoing is in conflict
                // for the message stream with the identifier.
                DMESG_PB_SET_MSG_SOURCEWRITEHANDLERIDENTIFIER(dmesgPbWrite,
                                                              this->m_name);

                bool ready = m_ready.test(std::memory_order_relaxed);
                if (ready || dmesgPbWrite.type() == dmn::DMesgTypePb::sys) {
                  if (dmesgPbWrite.type() != dmn::DMesgTypePb::sys) {
                    this->sendPendingOutboundQueueMessage();
                  }

                  dmesgPbWrite.SerializeToString(&serialized_string);
                  m_output_handler->write(serialized_string);

                  if (dmesgPbWrite.type() != dmn::DMesgTypePb::sys) {
                    m_topic_last_dmesgpb[dmesgPbWrite.topic()] = dmesgPbWrite;
                  } else if (ready) {
                    this->sendPendingOutboundQueueMessage();
                  }
                } else {
                  auto &pendingQueue =
                      m_topic_outbound_pending_dmesgpb[dmesgPbWrite.topic()];
                  pendingQueue.push_back(dmesgPbWrite);
                }
              },
              this, dmesgPbWrite);
        }
      },
      handlerConfig);

  m_subscript_handler->setConflictCallbackTask(
      [this](Dmn_DMesgHandler &handler, const dmn::DMesgPb) -> void {});
}

void Dmn_DMesgNet::createTimerProc() {
  if (m_input_handler && m_output_handler) {
    // into MasterPending
    m_timer_proc = std::make_unique<dmn::Dmn_Timer<std::chrono::nanoseconds>>(
        std::chrono::nanoseconds(DMN_DMESGNET_HEARTBEAT_IN_NS),
        [this]() -> void {
          this->addExecTask([this]() mutable -> void {
            if (this->m_sys.body().sys().self().state() ==
                dmn::DMesgStatePb::MasterPending) {
              this->m_master_pending_counter++;

              if (this->m_master_pending_counter >=
                  DMN_DMESGNET_MASTERPENDING_MAX_COUNTER) {
                this->m_master_pending_counter = 0;

                auto *self =
                    this->m_sys.mutable_body()->mutable_sys()->mutable_self();
                DMESG_PB_SYS_NODE_SET_STATE(self, dmn::DMesgStatePb::Ready);
                DMESG_PB_SYS_NODE_SET_MASTERIDENTIFIER(self, this->m_name);

                struct timeval tval{};
                gettimeofday(&tval, nullptr);

                DMESG_PB_SYS_NODE_SET_UPDATEDTIMESTAMP_FROM_TV(self, tval);

                m_ready.test_and_set(std::memory_order_relaxed);
                m_ready.notify_all();
              }
            } else if (this->m_sys.body().sys().self().state() ==
                       dmn::DMesgStatePb::Ready) {
              if (this->m_sys.body().sys().self().masteridentifier() !=
                  this->m_sys.body().sys().self().identifier()) {
                this->m_master_sync_pending_counter++;

                if (this->m_master_sync_pending_counter >=
                    DMN_DMESGNET_MASTERSYNC_MAX_COUNTER) {
                  this->m_master_sync_pending_counter = 0;
                  this->m_last_remote_master_timestamp = {};

                  auto *self =
                      this->m_sys.mutable_body()->mutable_sys()->mutable_self();

                  DMESG_PB_SYS_NODE_SET_MASTERIDENTIFIER(self, "");
                  DMESG_PB_SYS_NODE_SET_STATE(self,
                                              dmn::DMesgStatePb::MasterPending);

                  m_ready.clear(std::memory_order_relaxed);
                }
              }
            }

            this->m_sys_handler->write(this->m_sys);

            const bool master =
                this->m_sys.body().sys().self().masteridentifier() ==
                this->m_sys.body().sys().self().identifier();

            // if self is a master, and it is becoming master or # of neighbor
            // increase, let resend prior last message per topic.
            // FIXME: maybe it is good that master resend them prioritically?
            if (m_output_handler && master &&
                ((master != m_is_master) ||
                 (m_number_of_neighbor !=
                  this->m_sys.body().sys().nodelist().size()))) {
              for (auto &topic_dmesgpb : m_topic_last_dmesgpb) {
                dmn::DMesgPb pb = topic_dmesgpb.second;

                DMESG_PB_SET_MSG_PLAYBACK(pb, true);
                DMESG_PB_SET_MSG_SOURCEWRITEHANDLERIDENTIFIER(pb, this->m_name);

                std::string serialized_string{};
                pb.SerializeToString(&serialized_string);
                m_output_handler->write(serialized_string);
              }
            }

            m_number_of_neighbor = this->m_sys.body().sys().nodelist().size();
            m_is_master = master;
          });
        });
  } else {
    auto *self = this->m_sys.mutable_body()->mutable_sys()->mutable_self();
    DMESG_PB_SYS_NODE_SET_STATE(self, dmn::DMesgStatePb::Ready);
    DMESG_PB_SYS_NODE_SET_MASTERIDENTIFIER(self, this->m_name);
  }
}

auto Dmn_DMesgNet::getLastTopicCacheInternal()
    -> std::unordered_map<std::string, dmn::DMesgPb> & {
  return this->m_topic_last_dmesgpb;
}

void Dmn_DMesgNet::sendPendingOutboundQueueMessage() {
  assert(m_ready.test());

  if (m_output_handler) {
    for (auto &p : m_topic_outbound_pending_dmesgpb) {
      for (auto &dmesgPb : p.second) {
        std::string serialized_string{};

        dmesgPb.SerializeToString(&serialized_string);
        m_output_handler->write(serialized_string);

        if (dmesgPb.type() != dmn::DMesgTypePb::sys) {
          m_topic_last_dmesgpb[dmesgPb.topic()] = dmesgPb;
        }
      }

      p.second.clear();
    }
  }
}

void Dmn_DMesgNet::reconciliateDMesgPbSys(const dmn::DMesgPb &dmesgpb_other) {
  auto other = dmesgpb_other.body().sys().self();
  auto *self = this->m_sys.mutable_body()->mutable_sys()->mutable_self();

  struct timeval tval{};
  gettimeofday(&tval, nullptr);

  if (self->state() == dmn::DMesgStatePb::MasterPending &&
      other.state() == dmn::DMesgStatePb::Ready) {
    assert(self->masteridentifier().empty());
    assert(!other.masteridentifier().empty());

    DMESG_PB_SYS_NODE_SET_STATE(self, dmn::DMesgStatePb::Ready);
    DMESG_PB_SYS_NODE_SET_MASTERIDENTIFIER(self, other.masteridentifier());

    DMESG_PB_SYS_NODE_SET_UPDATEDTIMESTAMP_FROM_TV(self, tval);

    this->m_last_remote_master_timestamp = tval;
    this->m_master_pending_counter = 0;
    this->m_master_sync_pending_counter = 0;
    this->m_sys_handler->write(this->m_sys);

    m_ready.test_and_set(std::memory_order_relaxed);
    m_ready.notify_all();

    this->sendPendingOutboundQueueMessage();
  } else if (self->state() == dmn::DMesgStatePb::Ready) {
    assert(!self->masteridentifier().empty());
    assert(0 == this->m_master_pending_counter);

    if (other.identifier() == self->masteridentifier()) {
      if (other.state() == dmn::DMesgStatePb::Ready) {
        this->m_master_sync_pending_counter = 0;
        this->m_last_remote_master_timestamp = tval;
      } else {
        /* other node relinquish its self-proclaim master state
         * so local node also reset the master state
         */
        assert(other.masteridentifier().empty());

        DMESG_PB_SYS_NODE_SET_STATE(self, dmn::DMesgStatePb::MasterPending);
        DMESG_PB_SYS_NODE_SET_MASTERIDENTIFIER(self, "");

        DMESG_PB_SYS_NODE_SET_UPDATEDTIMESTAMP_FROM_TV(self, tval);

        this->m_last_remote_master_timestamp = {};
        this->m_master_pending_counter = 0;
        this->m_master_sync_pending_counter = 0;
        this->m_sys_handler->write(this->m_sys);

        m_ready.clear(std::memory_order_relaxed);
      }
    } else if (other.state() == dmn::DMesgStatePb::Ready &&
               other.masteridentifier() != self->masteridentifier()) {
      assert(!self->masteridentifier().empty());
      assert(!other.masteridentifier().empty());

      if (other.initializedtimestamp().seconds() <
              self->initializedtimestamp().seconds() ||
          (other.initializedtimestamp().seconds() ==
               self->initializedtimestamp().seconds() &&
           other.initializedtimestamp().nanos() <
               self->initializedtimestamp().nanos())) {
        // follow other node's masteridentifier() as other node has higher
        // seniority than local node.

        DMESG_PB_SYS_NODE_SET_MASTERIDENTIFIER(self, other.masteridentifier());
        DMESG_PB_SYS_NODE_SET_UPDATEDTIMESTAMP_FROM_TV(self, tval);

        this->m_last_remote_master_timestamp = tval;
        this->m_master_pending_counter = 0;
        this->m_master_sync_pending_counter = 0;
        this->m_sys_handler->write(this->m_sys);
      }
    }
  } // if (self->state() == dmn::DMesgStatePb::Ready)

  int index = 0;
  while (index < this->m_sys.mutable_body()->mutable_sys()->nodelist().size()) {
    if (other.identifier() == this->m_sys.mutable_body()
                                  ->mutable_sys()
                                  ->nodelist()
                                  .Get(index)
                                  .identifier()) {
      break;
    }

    index++;
  }

  if (other.state() == dmn::DMesgStatePb::Destroyed) {
    if (index >= this->m_sys.mutable_body()->mutable_sys()->nodelist().size()) {
      // do nothing
    } else {
      this->m_sys.mutable_body()
          ->mutable_sys()
          ->mutable_nodelist()
          ->DeleteSubrange(index, 1);
    }
  } else {
    if (index >= this->m_sys.mutable_body()->mutable_sys()->nodelist().size()) {
      this->m_sys.mutable_body()->mutable_sys()->add_nodelist();
    }

    DMESG_PB_SYS_SET_NODELIST_ELEM_IDENTIFIER(this->m_sys, index,
                                              other.identifier());
    DMESG_PB_SYS_SET_NODELIST_ELEM_MASTERIDENTIFIER(this->m_sys, index,
                                                    other.masteridentifier());
    DMESG_PB_SYS_SET_NODELIST_ELEM_STATE(this->m_sys, index, other.state());
    DMESG_PB_SYS_SET_NODELIST_ELEM_INITIALIZEDTIMESTAMP(
        this->m_sys, index, other.initializedtimestamp());
    DMESG_PB_SYS_SET_NODELIST_ELEM_UPDATEDTIMESTAMP(this->m_sys, index,
                                                    other.updatedtimestamp());
  }
} // method reconciliateDmesgPbSys

} // namespace dmn
